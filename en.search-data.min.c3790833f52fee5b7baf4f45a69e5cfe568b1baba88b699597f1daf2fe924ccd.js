'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':3,'href':'/posts/try-hack-me/basic-pentesting/','title':"Basic Pentesting",'section':"Try Hack Me",'content':"This Try Hack Me room guided users through the basics of web application pentesting. I learned about SMB enumeration and bruteforcing domains. This walkthrough also introduces bruteforcing logins with hydra and once the machine is compromised, elevating user privileges.\nTools #   nmap gobuster hydra linenum  Walkthrough #  First things first let\u0026rsquo;s scan the box. I used the command nmap -sV -sS $IP and redirected the output to the file nmap/nmap.txt. It looks like there is an http server on this box. Let\u0026rsquo;s try and connect to it to see if it is actually accessible. Doesn\u0026rsquo;t look like we can access it. Let\u0026rsquo;s run a gobuster scan on the domain to just see if we can access any other pages. After running the command gobuster dir -u http://$IP:80 -w /usr/share/dirbuster/wordlists/directory-list-2.3-small.txt, we can see that there is a directory called development. Let\u0026rsquo;s go to it in the browser and take a look.\nThis is a great find because it indexes what we have in the directory. It looks like theses are internal notes. You can view them in the loot directory. To sum up the notes, it sounds like the user J has a weak password. Our nmap scan showed that then ssh port was open we we might be able to try and brute force some credentials with hydra. After doing some research it looks like hydra might not be the first step. To figure out the users we need to enumerate the SMB port with the tool enum4linux. Use the command enum4linux -a $IP to enumerate the SMB configuration. I outputted this to a file called smb_enum.txt it found two users, jan and kay. Now that we have these usernames we can use hydra to bruteforce jan\u0026rsquo;s ssh password since we know she has a weak password. Use the command hydra -l jan -P /usr/share/wordlists/rockyou.txt $IP so start the attack. Once the attack has been completed we can see that jan\u0026rsquo;s password is armando. You can see the outputs in hydra/hydra.txt\nusername: jan password: armando Next I enumerated the possible exploits on our target machine. I used this article to learn how to use LinEnum to scan for vulnerabilities on the target machine. First I sshed into the machine then navigated to /var/tmp so that I could copy the LinEnum script onto the machine. Then I ran the script. It looks like kay might had misconfigured her ssh files. If we copy her private key and has it we should be able to find out her password with John. First exfiltrate the private key. Next, use the command python /usr/share/john/ssh2john.py id_rsa \u0026gt; id_rsa.hash. Now we can use JtR to break this hash against the RockYou wordlist. Use the command /usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash against the has to crack it. And soon enough the password pops out as beeswax.\nusername: kay password: beeswax Now if we try to connect to the server with user kay we can use her passphase to use the private key. Use the command ssh -i id_rsa kay@$IP then enter beeswax when prompted for the private key password. If you get errors saying that the private key has bad permissions you can use the command chmod 600 id_rsa to fix that. Now we have access to the user kay. Cat out the password.bak file to get the final password and we are done! Congratulations!\nAfter some more investigating and research online, it also looks like we may even be able to become the root user from kay. If we run the command sudo -l and put in the password we just got we can see that kay can run sudo commands. So if we try to use the command sudo su we should be able to switch our user to root. And what do you know it works! There is also a flag in /root/flag.txt check it out.\n"});index.add({'id':5,'href':'/posts/try-hack-me/blue/','title':"Blue",'section':"Try Hack Me",'content':"Blue explores the dated, but widespread EternalBlue exploit. This exploit was used in the WannaCry ransomware attack which crippled healthcare systems and spread to millions of computers in a matter of days. In this room we are prompted to exploit this vulnerability using Metasploit.\nTools #   metasploit nmap  Walkthrough #  First things first. Let\u0026rsquo;s conduct a scan on the box using the command nmap -sS -sV -A $IP and pipe the output to the file nmap_out.txt. You can review the scan results there. Looking at the results the machine is running Windows 7 Professional 7601. If we google this version number we can find out that this version might be vulnerable to the \u0026ldquo;EternalBlue\u0026rdquo; (MS17-010) vulnerability. You can read more about it here. Now that we are done with recon, we can begin to try and gain access.\nTo gain access we are going to be using metasploit. To start metasploit use the command msfconsole. Then let\u0026rsquo;s ping the server just to be sure that we can connect. ping $IP. In the metasploit console we can use the command search MS17-010 to see exploits we can use. Next we can see payload 3 that has the title exploit/windows/smb/ms17_010_eternalblue. This is the code will will use to run against the machine. Now that these payloads are found we can use the command use 3 to load the payload. Now that we have our payload set we can the options. Use the command show options to see which options we need to set in order to use our attack. We can see that the only field that is required but not set is the RHOSTS. To set this field we can use the command set RHOSTS 10.10.100.140. Now when we do show options again we should be able to see our target IP address. Now that all the options are set run the command exploit to launch our payload.\nNow that we have access to the machine that we want, we can upgrade our shell to a meterpreter shell. The easy way to do this, given that we have already put the shell in the background using CTRL-Z. We can use the command sessions to see the sessions. In my instance the session we are interested in has the ID 1. So I will use the command sessions -u 1. But you can also use the module post/multi/manage/shell_to_meterpreter, then use the command use post/multi/manage/shell_to_meterpreter. Now that we are using the post exploit module we can set the SESSION option to the session ID. Use the command set SESSION 1. Now that the session is set, let\u0026rsquo;s fire up the meterpreter. Now let\u0026rsquo;s run. Once execution is complete press enter and select the new meterpreter session from our available sessions. Use the command sessions 2. Now that we are in the meterpreter shell we can use the command shell then whoami to verify that we are the nt authority\\system user. Now let\u0026rsquo;s take a look at the processes using the command ps. Write down a process id towards the bottom of the list to migrate to. This might be unstable and not work the first time. If it fails try again (this is what tryhackme says). I used the LiteAgent.exe process and it worked. Now that we have bigrated the process let\u0026rsquo;s get the user\u0026rsquo;s hashes. Use the command hashdump and if the privileges were escalated correctly we should see all the users and their hashes. We can also see that there is a user named \u0026lsquo;Jon\u0026rsquo;. Now to crack his password. I used the website CrackStation. To crack the password. Turns out this user\u0026rsquo;s password is alqfna22.\nThe first flag can be found in the root directory in the file flag1.txt. The third flag is in the user Jon\u0026rsquo;s documents. The second flag is found in the directory C:/Windows/system32/config. This is also the directory where windows passwords are stored. Interesting stuff.\nThis was a fun box and I feel like I have a better understanding of navigating through Windows directories and using the metasploit.\n"});index.add({'id':6,'href':'/posts/try-hack-me/ice/','title':"Ice",'section':"Try Hack Me",'content':"Ice is the extension to the Blue room. In this room we learn more about windows recon, exploitation and escalation. This box uses a vulnerable service called Icecast which allows us to access the machine using metasploit, then elevate those privileges by abusing a spool process.\nTools #   nmap metasploit  Walkthrough #  First things first. Nmap scan. I used the command sudo nmap -sV -A -sS $IP then piped the output to nmap/nmap.txt. From the results it looks like there is a webserver open on port 8000 and port 5357. On port 800 there is an interesting software called Icecast running. Let\u0026rsquo;s do some research about this. It looks like Icecast is a software that allows a computer to be a media server.\nTo learn about the vulnerability this machine has TryHackMe gave us a big hint. It told us that there is a vulnerability with the level 7.5 on cvedetails.com. There are two exploits with this level on cvedetails that deal with Icecast. The one we are looking for is CVE-2004-1561. Its type is execute code overflow. Now that we know what exploit this machine might fall victim too let\u0026rsquo;s fire up metasploit and load out module in. To do this type msfconsole then search icecast and finally use 0 because this exploit is the only on in metasploit for Icecast. Next we will use show options to see what we need in order to execute the exploit. Turns out the required option is RHOSTS. Now let\u0026rsquo;s set the RHOSTS to our target IP. Use the command set RHOSTS 10.10.220.176. Finally lets run the exploit! Use the exploit command.\nNow that we have a foothold we can being escalating our privileges. First TryHackMe asks what shell we are using. And for this exploit metasploit is nice enough to throw us into the meterpreter shell. Now we can take a look at the processes running on the machine. To do this we can run the command ps to see the current processes. Turns out that a user named \u0026lsquo;Dark\u0026rsquo; is running Icecast. Now the build of Windows that this machine is running is 7601. I just took a look at my nmap scan to figure this out. We can also use the command sysinfo. This also tells us that the machine is on an \u0026lsquo;x64\u0026rsquo; architecture. Now let\u0026rsquo;s run run post/multi/recon/local_exploit_suggester which will suggest us some exploits to run against this machine. After running these are our results:\n[+] 10.10.220.176 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ikeext_service: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ms10_092_schelevator: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ms13_053_schlamperei: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ms13_081_track_popup_menu: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ms14_058_track_popup_menu: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ms15_051_client_copy_image: The target appears to be vulnerable. [+] 10.10.220.176 - exploit/windows/local/ppr_flatten_rec: The target appears to be vulnerable. TryHackMe wants us to use the first one. Suspend the current session using CTRL-Z then use the command use exploit/windows/local/bypassuac_eventvwr to load the exploit. Then set the session to 1 using set SESSION 1 (This might be different depending on how you used metasploit. If you need to check use the command sessions). Now that we have set the session we need to set the listener ip. We can type ip addr in the command line to get out TryHackMe address. Your TryHackMe IP should be the one under the tun0 section. You can also check this in the access tab on the website. In my case my internal IP is 10.9.12.124. Now run the exploit and connect to the newly created session using the command sessions #. Now that we have connected we can use the command getprivs to see what processes we have access to. One of these process should allow us to take ownership of files. Based on the list output from getprivs it looks like \u0026lsquo;SeTakeOwnershipPrivilege\u0026rsquo; is what we are looking for. Now that we know how to gain access to what we want we need to do it.\nNow that we are on the machine we are running on a process that is being run under the \u0026lsquo;Dark\u0026rsquo; user. However even though we have escalated privileges as \u0026lsquo;NT AUTHORITY\\SYSTEM\u0026rsquo; we are not in an escalated process. To get to an escalated process we can use the ps command to see the processes running. Then we can migrate to a process that is running as NT AUTHORITY\\SYSTEM. For this box we are going to pick the spoolsv.exe process because is it running on the same architecture that the lsass service is running. lsass is our target. Now let\u0026rsquo;s migrate. On my box the spoolsv.exe process id is 1400 so I will use the command migrate 1400 to move to that process. Next I am going to load in the meterpreter extension Mimikatz using the command load kiwi, kiwi being the Minikatz version. Minikatz will allow us to dump the passwords. To get the credentials use the command creds_all. We can get all the hashes using the command hashdump. We can also watch the user\u0026rsquo;s screen using screenshare or listen to their microphone using the command record_mic. We can also change time stamps using the command timestomp. This could be used to confuse investigators after an attack. If we wanted to we could also create a \u0026lsquo;golden ticket\u0026rsquo; with Minikatz that allows us to easily authenticate other users on the system.\n"});index.add({'id':7,'href':'/posts/hack-the-box/challenges/fuzzy/','title':"Fuzzy",'section':"Challenges",'content':"Fuzzy challenged the user on the basics of fuzzing and taught me how to use wfuzz and other techniques to learn information about my target machine. I suggest anyone who would like to learn about fuzzing take on this challenge.\nTools #   gobuster wfuzz  Walkthrough #  First thing I am going to try and do is navigate to robots.txt, but it looks like it is not there. Next we are going to run gobuster to figure out if there are any other server urls that we can navigate to and exploit. The output of this scan is in dirb_out.txt. Now we can see that there is a directory called /api/.\nNext we are going to do another scan in the api directory using the command gobuster dir -u http://docker.hackthebox.eu:31883/api -w /usr/share/wordlists/dirb/common.txt -x .php,.html,.htm,.js. I used the -x argument so specify the extensions I wanted to search for. You can see the results in dirb_file_out.txt We find the file action.php and when we try to visit it in the browser it says that there needs to be a parameter. So we need to find that.\nTo find the hidden parameter we can use wfuzz to fuzz the parameter name and find the return that request that returns something of value to us. Let\u0026rsquo;s run the command wfuzz -c -w /usr/share/dirb/wordlists/big.txt http://docker.hackthebox.eu:31883/api/action.php?FUZZ=test to start fuzzing the parameter names. Check out the output in paramfinder_out.txt it looks like the most of our responses are returning 4 words. If we user grep -v we can filter out all the responses that contain 4 words and maybe find the parameter name that returns something else. Run the command cat paramfinder_out.txt | grep -v \u0026quot;4 W\u0026quot; and we see that reset returns something with 5 words. Let\u0026rsquo;s navigate to the web browser and see what is being returned. If you take a look at the web browser it seems that we are entering the wrong account ID. Well that is something. It looks like we found the parameter for this action.php file. Now to find our user.\nIn order to find the user we are going to use another wfuzz scan. Who would have thought that a challenge named \u0026ldquo;fuzzy\u0026rdquo; would require this much fuzzing. We can fuzz the user ID by using the range argument for wfuzz. You can read about it here. Let\u0026rsquo;s use the command wfuzz -z range,0-100 http://docker.hackthebox.eu:31883/api/action.php?reset=FUZZ \u0026gt; digitfuzz.txt. These results can be found in digitfuzz.txt. Again we notice that most of the parameter values return 5 words so let\u0026rsquo;s try an grep -v again to filter out all the 5 word returns. Using the command cat digitfuzz.txt | grep -v \u0026quot;5 W\u0026quot; returns to us the user ID of the user who\u0026rsquo;s reset was successful. Now if we go to the web browser and navigate to http://docker.hackthebox.eu:31883/api/action.php?reset=[ID] replacing [ID] with the ID that was found by our wfuzz scan you should be able to see the flag.\n"});index.add({'id':8,'href':'/posts/try-hack-me/vulnversity/','title':"Vulnversity",'section':"Try Hack Me",'content':"Vulnversity walks through how to preform recon on targets and look for possible points of entry for payloads such as reverse shells. On this box port 3333 is running a webserver. After dirbusting the webserver we find a path called internal where we are able to upload php files. From there we can upload a reverse shell in php and get access to the machine. Once on the machine we check file permissions to find an avenue to escalate our privileges.\nTools #   nmap gobuster  Walkthrough #  export IP=10.10.22.134 [Task 2] #  This task is centered around using nmap. A port scanner that can give us information from what ports are open on a host, to the software running on those open ports. For this box we are using the IP 10.10.22.134, and to conduct our nmap scan we can use the command nmap -sV -A -v 10.10.22.134. I am using the flags -sV to tell us the version of services running on each port, -A to enable OS detection and -V to enable verbose mode. You can checkout the output of my scan in nmap_out.txt. When analyzing out scan results we can see that there are 6 ports open: 21, 22, 139, 445, 3128, and 3333. We see a squid proxy running on port 3128, version 3.5.12 to be exact. If we use the flag -p-400 we will scan all the ports up to 400. The flag -n will not do DNS resolution, and the machine is probably running Ubuntu because it is what ports 22, 445, and 3333 are all running on. The web server (Apache) is running on port 3333.\n[Task 3] #  For this task we are going to run dirbuster to find the url path that has an upload form page. We can use the command gobuster dir -u http://$IP:3333 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt. The output will be located in the file gobuster_out.txt. If we take a look in here we can notice that there is a path called /internal/ if we navigate to this path in the web browser we can see that it is indeed a form upload page.\n[Task 4] #  After figuring out that the form does not want us to upload .php files we can make a custom wordlist to include the .php extensions. You can check out the wordlist in the phpext.txt file. Now we are going to try and find out what kind of file we are allowed to upload. Let\u0026rsquo;s use Burp to intercept a form upload then user the Intruder function to preform a sniper attack on the form using the wordlist we created earlier. After running the attack we find that the server will allow us to upload a .phtml file. This gives us the opportunity to maybe use a reverse PHP shell. We can download the reverse shell from here.\nNow to upload our reverse shell. First open the php-reverse-shell.php file and change the IP to your tun0 IP. Now rename the file to have the .phtml extension. Open the port with netcat so we can listen for incoming connections on our machine. Use the command nc -lvnp 1234. Upload the file to the webpage, then navigate to http://$IP:3333/internal/uploads/php-reverse-shell.phtml. This will execute the payload and you should see a connection on your netcat session. Once we get the reverse shell we can interact with the machine that the server is being hosted on.\nFor the next part I am not sure how to figure out what user was running the web server. I tried ps aux to get a list of all the processes and users and the only user that it says is running any apache instance is root, but that is not the correct answer. So I went to take a look at all the users. To do this I used the command cat /etc/passwd and found the user bill. Now we need to find his flag. If we navigate to his directory in /home/ the only file he has is one called user.txt which contains the flag.\n[Task 5] #  Now to escalate our privileges to become the root user! If we run the command find / -user root -perm -4000 -exec ls -ldb {} \\; we can find a files that we have permissions for. When running this the file /bin/systemctl stands out, because it allows us to user services we might not be able to execute otherwise. When systemctl runs it runs with root permission.\nNow we navigate to the /bin directory and spawn a shell using sh. Next we copy this modified script from GTFObins, using the SUID version.\nTF=$(mktemp).service echo '[Service] Type=oneshot ExecStart=/bin/sh -c \u0026quot;cat /root/root.txt \u0026gt; /tmp/output\u0026quot; [Install] WantedBy=multi-user.target' \u0026gt; $TF ./systemctl link $TF ./systemctl enable --now $TF Now use cat /tmp/output and the flag should be there! All done!\n"});index.add({'id':9,'href':'/posts/try-hack-me/shodan.io/','title':"Shodan.io",'section':"Try Hack Me",'content':"Shodan.io is a great tool that is constantly scanning the whole internet for open devices and can be very useful in the recon stages of pentesting. This room walks through how to use filters on Shodan.io and how to find specific information about your target.\nTools #   Shodan.io Ultratools ASN Search  Walkthrough #  [Task 2] Getting Started #  To solve task 2 read task_1_introduction.md, it is the article that was provided by THM and outlines how to search for ASNs using ultratools then using the ASN:[asn] filter on Shodan.io.\nFirst things first. In order to find out google.com\u0026rsquo;s ip address we can use the ping command. This command just sends a little packet of data to google.com and sees if anything is returned. You can see the output of my ping in google_ping.txt. Ping also gives us the IP address, which we see is 173.194.219.102. When we throw this IP into ultratools we see that google\u0026rsquo;s ASN is AS15169. Right below that, in the details we see that this ASN was allocated 2000-03-30 giving us the answer to the second question.\nNext, we do an ASN search on Shodan.io. Sign-in or create an account and then search ASN:AS15169. This will show us the devices on that ASN. If we take a look on the left side of the page, we can sea a map of where most of those devices are located. And based on the map, and the table underneath it most of the devices are located in the United States. If we continue to look at the left size we see a section called Top Products. Here we see that the biggest product is OpenSSH. So the most popular service is SSH and then the type they are using is OpenSSH. Finally we look at the Top Organizations section and see that google\u0026rsquo;s biggest service on this ASN is Google Cloud.\n[Task 4] Google \u0026amp; Filtering #  After reading task_3_filters.md these questions should be a breeze. Again we are using Shodan.io and combining filters to have a better range of search results.\nFirst off THM wants us to find out what the most popular OS running MySQL is on Google\u0026rsquo;s ASN, to do this we need to combine an ASN filter with a product filter. The search query becomes product:MySQL ASN:AS15169. Then the results come up and there it is, Linux 3.x is the top operating system! The next few answers we can find by going back to just an ASN filter. When we check out the results we see that the third most popular location of machines on Google\u0026rsquo;s ASN is in the EU. The next part kinda stumped me for a second. It asks which of the following three services is most popular on Google\u0026rsquo;s ASN: nginx, HTTP or HTTPs. Well if you take a look at the search results under the Top Products section, for me nginx is obviously the most popular with HTTP and HTTPs not even making the list, but given that the answer prompt is more than 5 characters wrong I went to looking else where. If you take a look under the ports you can see that the three most popular ports are 20, 443 and 80. 20 being FTP, 443 being TCP and 80 being HTTP. So based on this information, and based on the length of the answer prompt I went with Hypertext Transfer Protocol (HTTP).\nIn order to figure out what city that most of Google\u0026rsquo;s machines are in, we need to narrow down our search to search a country. Since the US has the most machines it makes sense to look there. So we can create a new search for filtering the ASN and the Country like so: ASN:AS15169 country:US. Once this returns the results we see that Mountain View has the most machines. Shocker right? It makes sense that the city home to Google\u0026rsquo;s largest campus also houses most of its machines. What I found even more interesting is that according to this ASN the second most machines are in Cumming. I really hope they don\u0026rsquo;t mean Cumming, Georgia, because that place seems to small to house the second most Google machines in the US on this ASN, but who knows. Maybe it could be where they are located for the Atlanta campus. On to the next question! Next we narrow down our search by city, specifically Oakland. We use the following filters ASN:AS15169 city:Oakland. Then scroll down to where it says Operating Systems and there we go, Windows Server 2008. Well after trying to submit the Windows Server 2008 flag, it doesn\u0026rsquo;t look like that right, however in my search results it is obviously the top OS. After a really good guess, I put 2010 instead and there we go, thats what they are looking for.\nFor the last question we can navigate to https://shodan.io/explore and take a look at the webcams section. Then using our handy dandy ASN filter, search for google devices. When we hit search, no results pop up. Good for Google! Nay is the answer.\n"});})();